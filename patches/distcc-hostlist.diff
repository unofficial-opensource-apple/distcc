This patch lets you list the distcc hosts in a file.  It also makes it 
possible to have a very, very, very, large list of hosts, and also 
dynamically add hosts to your pool (say, if you have the hosts file on an NFS 
export, as we do here).

So, apply this patch, and:

unset DISTCC_HOSTS
export DISTCC_HOSTS_FILE=/etc/distcc-hosts

(use distcc as usual).
DISTCC_HOSTS overrides DISTCC_HOSTS_FILE (for convenience's sake)

You may need to update the --help docs in distcc.c

Also attached is the colorgcc script I use here.  I had to make modifications 
to get it to support distcc.  Or at least I think I did.  The side effects 
are that it makes it work with some of those broken gcc autoconf that 
requires a one-word compiler.

Do what you wish with it.

Also, I hope you get better integration with SMP RSN (pardon the TLAs ;).  
distcc or no, g++ is still painfully slow.

Distcc is really fantastic, I like it a lot.  Thanks for the work!

-Charles

--- hosts.c.old	Wed Oct  9 08:58:04 2002
+++ hosts.c	Wed Oct  9 09:16:14 2002
@@ -72,6 +72,9 @@
 #include <errno.h>
 #include <time.h>
 #include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 
 #include "distcc.h"
 #include "trace.h"
@@ -107,9 +110,45 @@
     char *where;
 
     where = getenv("DISTCC_HOSTS");
-    if (!where) {
-        rs_log_warning("$DISTCC_HOSTS is not defined; can't distribute work");
-        return EXIT_BAD_HOSTSPEC;
+	if (!where) {
+        char *filename;
+        int file;
+        char buffer[4096];
+        int readcount;
+        char *listbuf=0;
+        int listbufsize=4096;
+        int listbuflen=0;
+        int parseresult;
+        
+        listbuf = malloc(4096);
+        
+        filename = getenv("DISTCC_HOSTS_FILE");
+        if (!filename)
+        {
+            rs_log_warning("$DISTCC_HOSTS or $DISTCC_HOSTS_FILE not defined;"
+                           " can't distribute work");
+            return 1;
+        }
+        file = open(filename, O_RDONLY);
+
+        while ((readcount = read(file, buffer, 4096)) > 0)
+        {
+            if (readcount+listbuflen > listbufsize)
+            {
+                char *temp;
+                temp = malloc(readcount+listbuflen);
+                memcpy(temp, listbuf, listbuflen);
+                free(listbuf);
+                listbuf = temp;
+                listbufsize = readcount+listbuflen;
+            }
+            memcpy(listbuf+listbuflen, buffer, readcount);
+        }
+        close(file);
+        /* ok, I've read the file, now have it parsed */
+        parseresult = dcc_parse_hosts(listbuf, ret_list, ret_nhosts);
+        free(listbuf);
+        return parseresult;
     }
 
     return dcc_parse_hosts(where, ret_list, ret_nhosts);
@@ -296,7 +335,7 @@
     if (*ret_nhosts) {
         return 0;
     } else {
-        rs_log_warning("$DISTCC_HOSTS is empty; can't distribute work"); 
+        rs_log_warning("$DISTCC_HOSTS or $DISTCC_HOSTS_FILE is empty; can't distribute work"); 
         return EXIT_BAD_HOSTSPEC;
     }
 }

